\section{Properties}
There are a number of interesting settings whose effects are deeply hidden within the framework. Properties are an easy way to access these settings and change them. Properties are represented by the class \src{DockProperties} which can be accessed through \src{getProperties} of \src{DockController}.

\src{DockProperties} is nothing else than a map. Instances of \src{PropertyKey} are used as keys. The type of the value depends on the key and the map is typesafe. With the help of a \src{DockPropertyListener} any object can be informed immediately when a value changes.

There are a number of keys and the remainder of this chapter will list all of the keys that are present in version 1.1.1. If not explicitly said otherwise, then any change in the properties will have an immediate effect. This list is only an overview, please have a look at the API documentation or the source code to find out about types and default values.

\warningbox{Some of these properties are accessed and changed by \src{DockTheme}s. It is still possible to override these properties, but clients should be careful and ensure not to break the theme.}

\subsection{Themes}
These properties either are only used by some \src{DockTheme}s, or are changed by \src{DockTheme}s.
\begin{description}
 \property{BasicTheme.BASIC\_COLOR\_SCHEME}{Colors of the \src{BasicTheme}}{Sets a strategy (acting like a map) that tells which \src{Color}s to use when the \src{BasicTheme} is selected.}
 \property{BubbleTheme.BUBBLE\_COLOR\_SCHEME}{Colors of the \src{BubbleTheme}}{Sets a strategy (acting like a map) that tells which \src{Color}s to use when the \src{BubbleTheme} is selected.}
 \property{BubbleTheme.ACTION\_DISTRIBUTOR}{Actions of the \src{BubbleTheme}}{Tells where a \src{DockAction} should appear: on a tab, on a info-component or on the titel of a \src{Dockable}}.
 \property{DockTheme.COMBINER}{Stacking \src{Dockable}s}{The default strategy for merging two \src{Dockable}s into one, for example by putting them together on a \src{StackDockStation}.}
 \property{DockTheme.DISPLAYER\_FACTORY}{\src{Dockable} decorations}{The displayer is a \src{Component} between a \src{Dockable} and its parent, the displayer adds some decorations, for example a border, to the \src{Dockable}.}
 \property{DockTheme.DOCKABLE\_MOVING\_IMAGE\_FACTORY}{Drag indicator}{Tells what image to show when the user drags a \src{Dockable} around.}
 \property{DockTheme.DOCKABLE\_SELECTION}{\src{Dockable} selection}{A \src{Component} which allows the user to select the focused \src{Dockable}.}
 \property{DockableSelector.INIT\_SELECTION}{Start \src{Dockable} selection}{If the user hits this \src{KeyStroke} a window pops up, the user can select the new focused \src{Dockable} on that window.}
 \property{DockTheme.BACKGROUND\_PAINT}{Background}{This strategy paints the background of various components, it may also make some component transparent.}
 \property{DockTheme.BORDER\_MODIFIER}{Borders}{An adapter that receives a \src{Border}, the adapter may replace the original border with a custom border.}
 \property{DockTheme.SPAN\_FACTORY}{Animations during drag and drop}{During drag and drop, the \src{Span}s are used for an animation where empty space seem to appear beneath the \src{Dockable}.}
 \property{DockTheme.STATION\_PAINT}{Painting during drag and drop}{A strategy used to paint on \src{DockStation}s during a drag and drop operation.}
 \property{DockTitle.ORIENTATION\_STRATEGY}{Text rotation on titles}{This strategy knows whether the orientation of a \src{DockTitle} is horizontal or vertical, it then tells how to rotate the text on the title.}
 \property{EclipseTheme.ECLIPSE\_COLOR\_SCHEME}{Colors of the \src{EclipseTheme}}{Sets a strategy {acting like a map} that tells which \src{Color}s to use when the \src{EclipseTheme} is selected.}
 \property{EclipseTheme.PAINT\_ICONS\_WHEN\_DESELECTED}{\src{EclipseTheme}: when to paint icons}{Tells whether icons should be painted on tabs when they are not selected.}
 \property{EclipseTheme.TAB\_PAINTER}{\src{EclipseTheme}: how to paint tabs}{A factory and strategy that defines the look of the tabs used by the \src{EclipseTheme}.}
 \property{EclipseTheme.THEME\_CONNECTOR}{\src{EclipseTheme}: tab configuration}{Tells where to paint tabs, and which \src{DockAction}s to show on these tabs.}
 \property{FlatTheme.FLAT\_COLOR\_SCHEME}{Colors of the \src{FlatTheme}}{Sets a strategy (acting like a map) that tells which \src{Color}s to use when the \src{FlatTheme} is selected.}
 \property{FlatTheme.ACTION\_DISTRIBUTOR}{Actions of the \src{FlatTheme}}{Tells where a \src{DockAction} should appear: on a tab, on a info-component or on the titel of a \src{Dockable}}.
 \property{IconManager.MINIMUM\_ICON\_SIZE}{Size of icons}{Defines the minimum size of icons, any icon smaller than this size will be treated as if it would be bigger.}
\end{description}

\subsection{Stations}
Properties related to \src{DockStation}s.
\begin{description}
 \property{FlapDockStation.BUTTON\_CONTENT}{\src{FlapDockStation}: button content}{Decides what content to show on the buttons, e.g. whether to show an icon or some text.}
 \property{FlapDockStation.BUTTON\_CONTENT\_FILTER}{\src{FlapDockStation}: button actions}{Filters the \src{DockAction}s that are shown on the button.}
 \property{FlapDockStation.LAYOUT\_MANAGER}{\src{FlapDockStation}: persistent layout}{Strategy to store and load properties, like the size, of \src{Dockable}s that are not necessarily known to the \src{FlapDockStation}.}
 \property{FlapDockStation.MINIMUM\_SIZE}{\src{FlapDockStation}: minimum size}{The minimum size of the station itself, this is specially important when the station does not have any children.}
 \property{FlapDockStation.WINDOW\_FACTORY}{\src{FlapDockStation}: windows}{A factory creating a \src{FlapWindow}s, this window is used to show one of the children of a \src{FlapDockStation}.}
 \property{ScreenDockStation.ATTRACTOR\_STRATEGY}{\src{ScreenDockStation}: Attraction and stickiness}{Defines which two windows are attracted or sticked together.}
 \property{ScreenDockStation.BOUNDARY\_RESTRICTION}{\src{ScreenDockStation}: Where the screen ends}{A definition of the boundaries of the screen, and how windows behave when they are pushed against the boundaries.}
 \property{ScreenDockStation.DROP\_SIZE\_STRATEGY}{\src{ScreenDockStation}: Size of new windows}{Tells how big a window is when it is created.}
 \property{ScreenDockStation.EXPAND\_ON\_DOUBLE\_CLICK}{\src{ScreenDockStation}: Fullscreen on mouse click}{Tells whether double clicking with the mouse can command a window to switch into the fullscreen mode.}
 \property{ScreenDockStation.FULL\_SCREEN\_STRATEGY}{\src{ScreenDockStation}: Definition of ``fullscreen''}{Strategy deciding whether a window is in fullscreen mode or not.}
 \property{ScreenDockStation.MAGNET\_STRATEGY}{\src{ScreenDockStation}: Implementation of stickiness}{An algorithm that implements magnetization, the algorithm is responsible for finding out which two windows are attract each other or stick together, and how to react when one of the windows is moved aorund.}
 \property{ScreenDockStation.PREVENT\_FOCUS\_STEALING\_DELAY}{\src{ScreenDockStation}: Issues with focus}{A short delay in which a window cannot steal the focus if the owner window of the \linebreak \src{ScreenDockStation} changed.}
 \property{ScreenDockStation.WINDOW\_CONFIGURATION}{\src{ScreenDockStation}: Configuration of windows}{A factory creating configurations for the windows, for example whether the window is resizeable.}
 \property{ScreenDockStation.WINDOW\_FACTORY}{\src{ScreenDockStation}: Implementation of windows}{A factory creating new windows.}
 \property{SplitDockStation.DIVIDER\_STRATEGY}{\src{SplitDockStation}: Moving the gaps}{This strategy is responsible for changing the location of the gaps when the user grabs them with the mouse.}
 \property{SplitDockStation.LAYOUT\_MANAGER}{\src{SplitDockStation}: Handling the layout}{Decides about size and location of the children, about what happens if the size of the \src{SplitDockStation} changes, and which drop operations are possible.}
 \property{SplitDockStation.MAXIMIZE\_ACCELERATOR}{\src{SplitDockStation}: Maximize a child}{Tells which keys the user has to hit to maximize a child.}
 \property{StackDockStation.COMPONENT\_FACTORY}{\src{StackDockStation}: How the tabs look like}{A factory creating a \linebreak \src{StackDockComponent}, this component is responsible for painting all the tabs.}
 \property{StackDockStation.IMMUTABLE\_SELECTION\_INDEX}{\src{StackDockStation}: Reaction on dropping a \src{Dockable}}{Whether dropping a \src{Dockable} changes the selected \src{Dockable} or not.}
 \property{StackDockStation.TAB\_CONTENT\_FILTER}{\src{StackDockStation}: The contents of the tabs}{An adapter telling what icon and text to show on the tabs.}
 \property{StackDockStation.TAB\_CONFIGURATIONS}{\src{StackDockStation}: How a small tab looks like}{A configuration telling how the tabs behave if space is running out.}
 \property{StackDockStation.TAB\_PLACEMENT}{\src{StackDockStation}: Where the tabs show up}{Tells on which side (left, top, right, bottom) the tabs appear.}
\end{description}

\subsection{Miscellaneous}
Some properties that do not fit in any other category.
\begin{description}
 \property{DockController.RESTRICTED\_ENVIRONMENT}{Applets and webstart}{A Java application has limited rights when executed as applet or from webstart. The framework however needs some special rights, for example to monitor the position of the mouse. If these rights are not available, the framework activates some workarounds (which are not very efficient). In such cases the framework is called to \emph{be running in a restricted environment}. The property is set automatically, and usually clients need only read access. They can change the property, with the danger that the application no longer works afterwards.}
 \property{DockAction.BUTTON\_CONTENT\_FILTER}{Show text on buttons}{\src{DockAction}s can be shown on buttons. Usually the button contains only the icon of the action, but this strategy allows to show the text (usually used in menus) of the actions as well.}
 \property{DockActionImportanceOrder.ORDER}{Importance of actions}{Tells the order of importance of a set of \src{DockAction}s. In a situation where there is not enough space to show all actions, the least imporant actions will disappear first. Clients can also use the annotation \src{DockActionImportance} to mark the importance of actions.}
 \property{TabPane.LAYOUT\_MANAGER}{Layout of tabs}{This strategy is used by \src{TabPane} to decide where to show tabs, menus or info-component.}
 \property{SingleTabDecider.SINGLE\_TAB\_DECIDER}{Always show tabs}{Usually tabs only appear when some \src{Dockable}s are stacked. This strategy tells whether \src{Dockable}s that are not stacked should still feature a tab.}
 \property{CombinedMenuContent.MENU\_CONTENT}{Drop down menu on stacks}{If there is not enough space to show all tabs on a \src{StackDockStation}, a menu appears where the user can see the missing tabs. How exactly this menu looks like and how it is implemented is defined by this property.}
 \property{PlaceholderStrategy.PLACEHOLDER\_STRATEGY}{Keep track of \src{Dockable}s}{Tells the \emph{placeholder} of a \src{Dockable}. The placeholder is left behind if a \src{Dockable} is removed from a station, this way the framework still knows the old place of the item. Clients using \src{DockFrontend} or the Common project should not change this property.}
 \property{DisablingStrategy.STRATEGY}{Disable items}{This strategy tells which items (titles, tabs, actions, \src{Dockable}s) are disabled. Items that are disabled have a different color and do not react to user input.}
 \property{DockRelocatorMode.NO\_COMBINATION\_MASK}{No stacking during drag and drop}{If this \src{KeyStroke} is pressed during a drag and drop operation, the framework will not combine \linebreak \src{Dockable}s. For example the framework will not create a new \linebreak \src{StackDockStation}.}
 \property{DockRelocatorMode.SCREEN\_MASK}{Forced floating during drag and drop}{If this \src{KeyStroke} is pressed during a drag and drop operation, the only valid target of the operation is a \src{ScreenDockStation}.}
 \property{DockFrontend.HIDE\_ACCELERATOR}{Close \src{Dockable}s}{If this \src{KeyStroke} is hit, the currently focused \src{Dockable} is closed - assuming the \src{Dockable} can be closed in the first place.}
 \property{AWTComponentCaptureStrategy.STRATEGY}{Dealing with AWT components}{Allows clients to implement code to take images from AWT components. There are some default strategies available, going from ``nice'' to ``ugly workaround''.}
 \property{GlassedPane.TOOLTIP\_STRATEGY}{Tooltips in applets and on webstart}{In a restricted environment the framework will use an invisible \src{Component} to catch all \src{MouseEvent}s. This component is also responsible for showing tooltips. This strategy allows clients to modify the tooltip behavior: how they are created, and what they show.}
\end{description}


\subsection{Gimmicks}
These properties are not really necessary, they might be interesting for applications with a lot customization.
\begin{description}
 \property{PropertyKey.DOCK\_STATION\_ICON}{\src{DockStation}: default icon}{This icon is shown by a \src{DockStation} unless some other icon is set.}
 \property{PropertyKey.DOCK\_STATION\_TITLE}{\src{DockStation}: default title}{This text is shown by a \src{DockStation} unless some other text is set.}
 \property{PropertyKey.DOCK\_STATION\_TOOLTIP}{\src{DockStation}: default tooltip}{This tooltip is shown by a \linebreak \src{DockStation} unless some other tooltip is set.}
 \property{PropertyKey.DOCKABLE\_ICON}{\src{Dockable}: default icon}{This icon is shown by a \src{Dockable} unless some other icon is set.}
 \property{PropertyKey.DOCKABLE\_TITLE}{\src{Dockable}: default title}{This text is shown by a \src{Dockable} unless some other text is set.}
 \property{PropertyKey.DOCKABLE\_TOOLTIP}{\src{Dockable}: default tooltip}{This tooltip is shown by a \src{Dockable} unless some other tooltip is set.}
\end{description}

\subsection{Glass Extension}
The Glass Extension provides some additional properties.
\begin{description}
 \property{EclipseThemeExtension.GLASS\_FACTORY}{Detailed configuration}{This factory creates the ``glass effect''.}
 \property{CGlassExtension.SMALL\_TAB\_SIZE}{Size of tabs}{Allows to make tabs a little bit smaller.}
\end{description}

\subsection{Toolbar Extension}
The Toolbar Extension provides some additional properties.
\begin{description}
 \property{ExpandableToolbarItemStrategy.STRATEGY}{Shrinking, Expanding, Stretching}{Each toolbar-item can appear in three different sizes, this strategy tells which sizes are available for which items. Clients usually have no need to implement this interface, instead the \src{Dockable}s should implement \src{ExpandableToolbarItem}.}
 \property{ToolbarGroupDockStation.DIVIDER\_STRATEGY\_FACTORY}{\src{ToolbarGroupDockStation}: Painting between \src{Dockable}s.}{This strategy allows the \src{ToolbarGroupDockStation} to paint some borders between its children.}
 \property{ToolbarGroupDockStation.HEADER\_FACTORY}{\src{ToolbarGroupDockStation}: header component}{With this factory a client can add a \src{Component} at the top end of a \src{ToolbarGroupDockStation}.}
 \property{ToolbarGroupDockStation.SCROLLBAR\_FACTORY}{\src{ToolbarGroupDockStation}: scrollbars}{This factory creates scrollbars that are shown on a \src{ToolbarGroupDockStation}.}
 \property{ToolbarDockStation.GAP}{\src{ToolbarDockStation}: gap between children}{An integer telling how much space should be between the children of a \src{ToolbarDockStation}.}
 \property{ToolbarDockStation.SIDE\_GAP}{\src{ToolbarDockStation}: gap between border and children}{An integer telling how much space should be between the border and the children of a \src{ToolbarDockStation}.}
 \property{ToolbarStrategy.STRATEGY}{Toolbar behavior}{This strategy tells how different parts of the Toolbar Extension fit together. For example it can tell whether a \src{Dockable} can be a child of a toolbar-station, or not.}
\end{description}