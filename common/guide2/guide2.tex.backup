\documentclass[a4paper,10pt]{article}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{textcomp}

\lstset{language=Java}
\lstset{breaklines=true, numbers=left}
\lstset{tabsize=4}

\definecolor{CommentColor}{rgb}{0,0.5,0} 
\definecolor{KeywordColor}{rgb}{0,0,0.5}

\lstset{commentstyle=\scriptsize\color{CommentColor}\itshape}
\lstset{keywordstyle=\scriptsize\color{KeywordColor}\bfseries}
\lstset{basicstyle=\scriptsize}
\lstset{identifierstyle=\scriptsize}
\lstset{stringstyle=\scriptsize}

% \lstset{basicstyle=\ttfamily}

\definecolor{lightblue}{rgb}{0.7,0.7,1}
\definecolor{lightyellow}{rgb}{1,1,0.5}
\definecolor{lightred}{rgb}{1,0.5,0.5}
\definecolor{lightgreen}{rgb}{0.7,1,0.7}

\newcommand{\src}[1]{\texttt{#1}}

\newcommand{\qa}[2]{\item \textbf{Question:} #1 \\ \textbf{Answer:} #2}

\newcommand{\property}[4]{\item[#1] \mbox{ } \begin{description} \item[Type] \src{#2} \item[Default] #3 \item[Usage] #4  \end{description}}

% thanks to http://www.alfredklomp.com/programming/tex/macros/
\long\def\greybox#1#2#3{%
    \newbox\contentbox%
    \newbox\bkgdbox%
    \setbox\contentbox\hbox to \hsize{%
        \vtop{
            \kern\columnsep
            \hbox to \hsize{%
                \kern\columnsep%
                \advance\hsize by -2\columnsep%
                \parbox{0.1\hsize}{\includegraphics[width=\hsize]{#2}}%
                \hspace{0.025\hsize}%
                \advance\hsize by -0.125\hsize%
                \setlength{\textwidth}{\hsize}%
                \vbox{
                    \parskip=\baselineskip
                    \parindent=0bp
                    \parbox[c]{\hsize}{#3}
                }%
                \kern\columnsep%
            }%
            \kern\columnsep%
        }%
    }%
    \setbox\bkgdbox\vbox{
	\color{#1}
        \hrule width  \wd\contentbox %
               height \ht\contentbox %
               depth  \dp\contentbox
	\color{black}
    }%
    \wd\bkgdbox=0bp%
    \vbox{\hbox to \hsize{\box\bkgdbox\box\contentbox}}%
    \vskip\baselineskip%
}

\newcommand{\designbox}[1]{\greybox{lightgreen}{design}{#1}}
\newcommand{\classbox}[1]{\greybox{lightyellow}{class}{#1}}
\newcommand{\warningbox}[1]{\greybox{lightred}{stop}{#1}}
\newcommand{\infobox}[1]{\greybox{lightblue}{info}{#1}}

\title{DockingFrames 1.0.7 - Common}
\author{Benjamin Sigg}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}

\src{DockingFrames} is an open source Java Swing framework. This framework allows to write applications with floating panels. A floating panel is a \src{Component} that can be moved around by the user.

\src{DockingFrames} consists of two libraries, \src{Core} and \src{Common}. \src{Common} provides advanced functionalities that are built on top of \src{Core}. \src{Common} is a wrapper around \src{Core} and requires \src{Core} to work.

This document covers only \src{Common}, \src{Core} has its own guide. Not all the details of \src{Common} are described, but this document gives a nice oversight of the more important aspects.

You can utilize \src{Common} without understanding \src{Core}. But knowing at least some basics about \src{Core} will make life much easier.

\section{Notation}
This document uses various notations.

Any element that can be source code (e.g. a class name) and project names are written mono-spaced like this: \src{java.lang.String}. The package of classes and interfaces is rarely given since almost no name is used twice. The packages can be easily found with the help of the generated API documentation (\src{JavaDoc}).

\infobox{Tips and tricks are listed in boxes.}

\warningbox{Important notes and warnings are listed in boxes like this one.}

\classbox{Implementation details, especially lists of class names, are written in boxes like this.}

\designbox{These boxes explain \textit{why} some thing was designed the way it is. This might either contain some bit of history or an explanation why some awkward design is not as bad as it first looks.}

\section{Basics}
\src{Common} is partitioned into three sub-projects.

For clients the sub-project \src{common} is the most interesting. This project is the main layer above \src{Core} and also the most advanced layer in the whole framework.

The sub-project \src{facile} builds a basis for the features of \src{common}. In theory \src{facile} could be used without \src{common} but in practice the classes and interfaces are clearly designed to be used by or together with \src{common}.

Finally \src{support} consists of classes that are just used by \src{facile} and \src{common}. These classes have few to none relations with \src{DockingFrames} and can be used alone as well.

\subsection{Concepts}
In the understanding of \src{Common} an application consists of one main-window and maybe several supportive frames and dialogs. The main-window is most times a \src{JFrame} and the application runs as long as this frame is visible. The main-window consists of several panels. Each panel shows some part of the data. E.g. the panels of a browser could be the ``history'', the ``bookmarks'' and the open websites.

\src{Common} is an additional layer between panels and main-frame. It separates them and allows the user to drag \& drop panels.

To do so each panel gets wrapped into a \src{CDockable}. These \src{CDockable}s are then put onto \src{CStation}s. A controller (\src{CControl}) handles the movement of the dockables.

\begin{figure}[ht]
\centering
\includegraphics[scale=1]{app_without}
\caption{The standard application without \src{Common}. A main-frame and some panels that are put onto the main-frame.}
\label{fig:app_without}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[scale=1]{app_with}
\caption{An application with \src{Common}. The panels are wrapped into dockables. The dockables are put onto stations which lay on the main-frame. Dockables can be moved to different stations.}
\label{fig:app_with}
\end{figure}

\subsection{Hello World}
This chapter introduces the very basic vocabulary and shows a first example. In depth discussions of the concepts and implementations follow in the chapters afterwards.

\subsubsection{Setup controller}
The first step should be to create a \src{CControl}. \src{CControl} has more than one constructor, for this example it is sufficient to use the one constructor which requires only a \src{JFrame}. \src{CControl} monitors the state of this frame and ensures that the windows of \src{Common} are only visible when the frame is visible. Also dialogs created by the framework will have this frame as parent.

The code to create the controller looks like this:
\begin{lstlisting}
public class Example{
	public static void main( String[] args ){
		JFrame frame = new JFrame();
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		
		CControl control = new CControl( frame );
		
		...
\end{lstlisting}

\subsubsection{Setup stations}
The second step is to setup the layer between main-frame and dockables. There are different \src{CStation}s available. For example the \src{CMinimizeArea} shows minimized \src{CDockable}s. Instead of creating the stations manually one can also use a \src{CContentArea}. The \src{CContentArea} is a panel that consists of five stations. In the center a grid of dockables is shown, at the border four areas are reserved for minimized dockables.

There is always a default-\src{CContentArea} available, it can be accessed by calling \src{getContentArea} of \src{CControl}. If required additional \src{CContentArea}s can be created by the method \src{createContentArea} of \src{CControl}.

A \src{CContentArea} is a \src{JComponent}, so its usage is straight forward. Line \src{10} is the important new line in this code:
\begin{lstlisting}
public class Example{
	public static void main( String[] args ){
		JFrame frame = new JFrame();
		
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		
		CControl control = new CControl( frame );
		
		frame.setLayout( new GridLayout( 1, 1 ) );
		frame.add( control.getContentArea() );
		
		...
\end{lstlisting}

\infobox{\src{CControl} always creates an additional station for handling externalized dockables.}

\subsubsection{Setup dockables}
A \src{CDockable} is the thing that can be dragged and dropped by the user. A \src{CDockable} has a set of properties, e.g. what text to show as title, whether it can be maximized, what font to use when focused, and so on.
\src{CDockable}s are divided into two categories: ``single'' and ``multi'' dockables. These categories are explained later, for this first example single dockables are the correct choice. Single dockables are represented by the interface \src{SingleCDockable}. The class \src{DefaultSingleCDockable} provides an easy to use implementation.
In the code below new single dockables are created in lines \src{23-25} and \src{43-48}. They need to be registered at the \src{CControl} in lines \src{27-29}, otherwise they cannot be shown. Optionally the initial position can be set like in line \src{33} and \src{36}. There is no need to set the position of the first dockable \src{red}: since it is the first it gets per default all the space.

\begin{lstlisting}
import java.awt.Color;
import java.awt.GridLayout;

import javax.swing.JFrame;
import javax.swing.JPanel;

import bibliothek.gui.dock.common.CControl;
import bibliothek.gui.dock.common.CLocation;
import bibliothek.gui.dock.common.DefaultSingleCDockable;
import bibliothek.gui.dock.common.SingleCDockable;

public class Example{
	public static void main( String[] args ){
		JFrame frame = new JFrame();
		
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		
		CControl control = new CControl( frame );
		
		frame.setLayout( new GridLayout( 1, 1 ) );
		frame.add( control.getContentArea() );
		
		SingleCDockable red = create( "Red", Color.RED );
		SingleCDockable green = create( "Green", Color.GREEN );
		SingleCDockable blue = create( "Blue", Color.BLUE );
		
		control.add( red );
		control.add( green );
		control.add( blue );
		
		red.setVisible( true );
		
		green.setLocation( CLocation.base().normalSouth( 0.4 ));
		green.setVisible( true );
		
		blue.setLocation( CLocation.base().normalEast( 0.3 ) );
		blue.setVisible( true );
		
		frame.setBounds( 20, 20, 400, 400 );
		frame.setVisible( true );
	}
	
	public static SingleCDockable create( String title, Color color ){
		JPanel background = new JPanel();
		background.setOpaque( true );
		background.setBackground( color );
		
		return new DefaultSingleCDockable( title, title, background );
	}
}

\end{lstlisting}

\section{Foundation}
This chapter focuses on the foundation of \src{Common}: \src{CControl}, the stations and dockables.

\subsection{Dockables}
As mentioned in the previous chapter \src{CDockable}s fall in one of two categories: ``single'' or ``multiple''. Only one instance of a single dockable may exist during runtime, but many (or none) instance of a multiple dockable may exist. In many cases both kind of dockables have the same behavior, but there are some exceptions when it comes to the storage of their location.

Every \src{CDockable} needs to be registered at a \src{CControl}, the methods with name \src{add} can be used. They need to be made visible by calling \src{setVisible} of \src{CDockable}.

\designbox{The interface \src{CDockable} has some awkward methods whose implementation is already described in the documentation. \src{CDockable} is not intended to be implemented by clients, but to be used by them. There is a subclass \src{AbstractCDockable} which provides the correct implementation for these awkward methods. Even in the framework itself no class (except \src{AbstractCDockable}) implements \src{CDockable} directly. The only reason for the existence of \src{CDockable} is to provide an abstraction from the implementation.}

\infobox{A \src{CDockable} is not a \src{Dockable}, but internally references a \src{Dockable}. This \src{Dockable} is always of type \src{CommonDockable}. It can be accessed through the method \src{intern} of \src{CDockable}. Clients should avoid modifying this \src{Dockable} directly.}

\subsubsection{SingleCDockable}
The representation of a single dockable is \src{SingleCDockable}. A single dockable is created once, added to the control and made visible. It remains in memory until explicitly removed from the \src{CControl} or the application terminates.

In order to store attributes (like the position) persistently each \linebreak \src{SingleCDockable} requires a unique identifier.

Clients best use a \src{DefaultSingleCDockable}. A \src{DefaultSingleCDockable} can be used like a \src{JFrame}, for example it also has a content-pane, has methods to set the title-text, etc.

Examples for single dockables could be:
\begin{itemize}
  \item A browser has one panel ``history'', the panel is shown on a single dockable.
  \item A view that is most of the time invisible. A single dockable is created lazily the first time when the view is shown.
\end{itemize}

\subsubsection{MultipleCDockable}
\src{MultipleCDockable} are used if the number of instances is not known prior to runtime. Each kind of \src{MultipleCDockable} is associated with a \linebreak \src{MultipleCDockableFactory}. The framework can delete or create new instances of this kind of dockable whenever they are needed.

Clients are required to install the \src{MultipleCDockableFactory} before using any \src{MultipleCDockable}. There is a class \src{DefaultMultipleCDockable} which should provide all the features a client needs.

An example:
\begin{lstlisting}
CControl control = ...

MultipleCDockableFactory<MyDockable, MyLayoutInformation> = new ...
control.addMultipleDockableFactory( "unique id", factory );

MyDockable dockable = new ...
control.add( dockable );
\end{lstlisting}
Notice that in line \src{4} a unique identifier needs to be assigned to the factory.

Implementing a \src{MultipleCDockableFactory} is easy. There is a method to read and to write meta-information from or to a \src{MultipleCDockable}. Meta-information itself is a \src{MultipleCDockableLayout} which has methods to write or read its content to a stream (e.g. to file). There are no restrictions to what meta-information really is.

Examples for multiple dockables are:
\begin{itemize}
 \item A text-editor can show many documents at the same time. Each document is shown in its own dockable.
 \item A 3D modeling software allows to see the modeled object from different angles. Each camera is a dockable.
\end{itemize}

\infobox{In \src{Common} each \src{CDockable} requires to have a unique identifier. The framework will automatically create an identifier for \src{MultipleCDockable}s.}

\designbox{Why the distinction between single and multiple dockables? The algorithms to store and load the layout (place and size of dockables) can either use existing objects or create new dockables. Using existing objects is preferred because the overhead of creation can be - at least for complex views - high. Single and multiple \src{CDockable}s represent this gap.}

\subsubsection{Visibility}
A dockable is either visible or invisible. The user cannot interact with the dockable unless it is visible. There is more than one path to change visibility.

The direct approach is to call the method \src{setVisible} of \src{CDockable}. This method will show the dockable at its last known location.

A dockable is made visible implicitly if it is added to any station. This can happen if for example using a \src{CGrid} like explained in chapter \ref{sec:location}.

Finally the user can make a dockable invisible by clicking on its close-button. Every subclass of \src{DefaultCDockable} has the method \src{setCloseable} to change whether the user can click away the element.

Visibility can be monitored with a \src{CDockableStateListener}. Either for a single dockable by adding the listener directly to the dockable, or globally by adding the listener to \src{CControl}. An example:
\begin{lstlisting}
CDockable dockable = ...
		
dockable.addCDockableStateListener( new CDockableAdapter(){
  @Override
  public void visibilityChanged( CDockable dockable ){
    System.out.println( "Visibility changed to '" + 
                         dockable.isVisible() + "'" );
  }
});
\end{lstlisting}

 The default behavior of the close-action is to call \src{setVisible} with \src{visible} set to \src{false}, so overriding this method is an easy way to introduce some additional code that is executed directly before the dockable closes.

\classbox{The close-action can be replaced by calling \src{putAction} with the key \src{ACTION\_KEY\_CLOSE} of \src{CDockable}. The action can be replaced at any time. More about actions in chapter \ref{sec:action}.}

\infobox{If the method \src{setLocation} of \src{AbstractCDockable} is called before the dockable is made visible, then the dockable is made visible at the supplied location. More about locations in chapter \src{sec:location}.}

\subsubsection{Mode}
If a \src{CDockable} is visible then it always is in an extended-mode. The extended mode tells something about the behaviour of the dockable and where it is placed. There are four extended modes available:
\begin{description}
 \item[normalized] The normal state of a dockable. It is placed on the main-frame of the application, but only covers a fraction of the main-frame.
 \item[maximized] A maximized dockable takes all the space it gets and often covers other dockables.
 \item[minimized] A minimzed dockable is not directly visible. Only a button at one edge of the main-frame indicates the existance of the dockable. If the button is pressed then the dockable pops up. As soon as it loses focus it disapears again.
 \item[externalized] The dockable receives its own window. Per default the window is an undecorated \src{JDialog} and child of the main-frame.
\end{description}

Users can change the extended mode either by dragging the dockable to a new area, or by clicking some buttons that are visible in the title of each dockable.

Clients can access and change the extended mode by calling \linebreak \src{getExtendedMode} and \src{setExtendedMode} of \src{CControl}. A dockable has no extended mode if not visible. Furthermore clients can forbid a dockable to go into some extended modes. Methods like \src{setMaximizable} of \src{DefaultCDockable} allow that. Finally clients can exchange the button that must be pressed by the user by calling \src{putAction} of \src{AbstractCDockable}. Keys for \src{putAction} are declared as \src{String} constants in \src{CDockable} with names like \src{ACTION\_KEY\_MINIMIZE}.

\subsection{Stations}
Stations are needed to place and show \src{CDockable}s. A station provides the \src{Component}(s) (e.g. a \src{JPanel} or a dialog) that are the parents of the dockables. Stations are represented through the interface \src{CStation}.

\src{CStation}s delegate most of their work to some \src{DockStation} of \src{Core}. Like dockables a \src{CStation} requires a unique identifier. This identifier is used to persistently store and load layout information.

\warningbox{Currently only the existing \src{DockStation}s from \src{Core} are truly supported by \src{Common}. The \src{StateManager} makes a few assumptions what station is associated with what mode, e.g. a \src{FlapDockStation} is associated with mode ``minimized''. Future versions of the framework might be designed more open, allowing developers to add new modes or other associations. Some improvements were already introduced in version 1.0.7.}

\subsubsection{All in one: CContentArea}
The preferred way to create stations is to use a \src{CContentArea}. A \src{CContentArea} is not a single \src{CStation} but a panel containing many stations. Each content-area has a center area where dockables are layed out in a grid, and four small areas at the border where dockables show up when they are minimized.

There is a default-\src{CContentArea} present and can be accessed through \linebreak \src{getContentArea} of \src{CControl}. A content-area can later be used like any other \src{Component}:
\begin{lstlisting}
JFrame frame = ...
CControl control = ...

CContentArea area = control.getContentArea();
frame.add( area );
\end{lstlisting}

If more than one content-area is needed then clients can use \linebreak \src{createContentArea} of \src{CControl} to create additional areas. These additional areas can later be removed through \src{removeContentArea}. The default content-area cannot be removed.

\infobox{The default content-area is create lazily. There is no obligation to use or create it, clients can as well directly call \src{createContentArea} or not use them at all.}

\warningbox{While \src{CContentArea} has a public constructor clients should prefer to use the factory method \src{createContentArea}. In future releases the constructor might be changed.}

To place dockables onto a content-area a \src{CGrid} can be of help. With the method \src{deploy} the content of a whole \src{CGrid} can be put onto the center area. More about \src{CGrid} and other mechanisms to position elements are listed up in chapter \ref{sec:location}.

\subsubsection{Center area: CGridArea}
A \src{CGridArea} is kind of a lightweight version of \src{CContentArea}. A grid-area contains normalized and maximized dockables. Other than a content-area it cannot show minimized dockables.

\src{CGridArea}s should be created through the factory method \src{createGridArea} of \src{CControl}. If it is no longer required it can be removed through the method \src{removeStation}.

Like \src{CContentArea} a \src{CGridArea} has the method \src{deploy} to add a whole set of dockables quickly to the area.

Usage of a grid-area could look like this:

\begin{lstlisting}
JFrame frame = ...
CControl control = ...

CGridArea center = control.createGridArea( "center" );
frame.add( center.getComponent() );
\end{lstlisting}
Notice that in line \src{5} the method \src{getComponent} has to be called. This method returns the \src{Component} on which the station lies.

\classbox{Some more things that might be interesting:
\begin{itemize}
\item A grid-area implements \src{SingleCDockable}, hence it can be a child of another area. Remember that the area must be manually added to the \src{CControl} as dockable.
\item The method \src{setMaximizingArea} influences of what happens when a child of the area gets maximized. If \src{true} was given to the method then the child gets maximized within the boundaries of the grid-area. Otherwise the child might cover the area or even be transfered to another area.
\end{itemize}}

\subsubsection{Minimized: CMinimizeArea}
Most things that were said for \src{CGridArea} hold true for \src{CMinimizeArea} as well. A minimize-area should be created through \src{createMinimizeArea} of \src{CControl}.

\subsubsection{Grouping Dockables: CWorkingArea}
The \src{CWorkingArea} is a subclass of \src{CGridArea}. The difference between them is, that the property \src{working-area} is \src{false} for a grid-area, but \src{true} for a \src{CWorkingArea}. 

Having this property set to \src{true} places some constraints on the station:
\begin{itemize}
\item Children of this station cannot be put moved to another station if that other station shows dockables in normalized mode. For a user this means that children can only be minimized, maximized or externalized, but not dragged away.
\item The user cannot drag dockables away from the station unless they are already children of the station.
\item If the station has no children then it appears as grey, empty space which does not go away.
\item Children of a working-area are not stored for temporary layout. For the user this means that applying a layout does neither affect the station, or dockables that can be put onto the station.
\end{itemize}

\src{CWorkingArea}s can be used to display a set documents. For example in an IDE (like \src{Eclipse} or \src{Netbeans}) each source file would get its own \src{CDockable} which then is put onto the working-area.

\infobox{The children of a \src{CWorkingArea} are often good candidates for being \src{MultipleCDockable}s.}

\section{Locations} \label{sec:location}
Location means position and size of a dockable. A location can be relative to some parent of a dockable or it can be fix.

\subsection{For a single dockable: CLocation}
The location of a single dockable is represented by a \src{CLocation}. The method \src{getBaseLocation} of \src{CDockable} gets the current location and the method \linebreak \src{setLocation} changes the current location.

Most subclasses of \src{CLocation} offer one or more methods to optain new locations. For example a \src{CGridAreaLocation} offers \src{north}. While \linebreak \src{CGridAreaLocation} represents just some \src{CGridArea}, the location optained through \src{north} represents the upper half of the grid-area. Clients can chain together method calls to create locations:
\begin{lstlisting}
CGridAreaLocation root = ...
CDockable dockable = ...
		
CLocation location = root.north( 0.5 ).west( 0.5 ).stack( 2 );
dockable.setLocation( location );
\end{lstlisting}
The chain of calls in line \src{4} creates a location pointing to the upper left quarter of some grid-area. Assuming there is a stack of dockables in that quarter, the location points to the third entry of that stack. In line \src{5} the location of \src{dockable} is set, the framework will try to set \src{dockable} at the exact location but cannot make any guarantees (e.g. if there is no stack in the upper left quarter, then framework cannot magically invent one).

To create a root-location clients can call one of the static factory methods of \src{CLocation} or directly instantiate the location. Calling the factory methods of \src{CLocation} is preferred.

Setting the location of a dockable \src{a} to the location of another dockable \src{b} will move away \src{a} from its position. As an example:
\begin{lstlisting}
CDockable a = ...
CDockable b = ...

CLocation location = a.getBaseLocation();
b.setLocation( location );
\end{lstlisting}

If \src{a} should remain at its place then the method \src{aside} of \src{CLocation} can create a location that is near to \src{a}, but not exactly \src{a}'s position:
\begin{lstlisting}[firstnumber=5]
b.setLocation( location.aside() );
\end{lstlisting}

\classbox{\src{CLocation} is a wrapper around \src{DockableProperty}. While each \src{DockableProperty} has its own API and concepts, \src{CLocation}s unify usage by providing the chain-concept. The chain-concept allows some typesafety and should reduce the amount of wrongly put together locations. }

\subsection{For a group of dockables: CGrid}
Sometimes it is necessary to set the position of several dockables at once. For example when the application starts up a default layout could be created. If dockables are minimized or externalized the position can simply be set with \src{CLocation}s. If dockables are shown normalized on a grid-area, a working-area, or the center of a \src{CContentArea} then things get more complex. Using \src{CLocation} would require a precise order in which to add the dockables, and some awkward coordinates to make sure they are shifted at the right place when more dockables become visible.

\src{CGrid} is a class that collects dockables and their boundaries. All this information can then be put onto a grid-like areas in one command. Furthermore a \src{CGrid} can also automatically register dockables at a \src{CControl}. An example:
\begin{lstlisting}
CControl control = ...

SingleCDockable single = new ...
MultipleCDockable multi = new ...

CGrid grid = new CGrid( control );

grid.add( 0, 0, 1, 1, single );
grid.add( 0, 1, 1, 2, multi );

CContentArea content = control.getContentArea();
content.deploy( grid );
\end{lstlisting}
The \src{CControl} created in line \src{6} will call the \src{add}-methods of \src{control} (line \src{1}) with any dockable that is given to it. In lines \src{8,9} two dockables are put onto the grid. The numbers are the boundaries of the dockables. In line \src{12} the contents of the grid are put onto \src{content}. The dockables \src{single} and \src{multi} will be arranged such that \src{multi} has twice the size of \src{single}.

Boundaries are relative to each other, there is no minimal or maximal value for a coordinate or size. \src{CGrid} is able to handle gaps and overlaps, but such defections might yield awkward layouts.

\warningbox{Make sure not to add a dockable twice to a \src{CControl}. If using a \src{CGrid} the \src{add} method of \src{CControl} must not be called. 

Also note that there is a second constructor for \src{CGrid} that does not have any argument. If that second constructor is used, then the \src{CGrid} will not add dockables to any \src{CControl}.}

\infobox{Dockables can also be grouped in a stack by \src{CGrid}. Any two dockables with the same boundaries are grouped. The \src{add} method uses a vararg-argument, more than just one dockable can be placed with the same boundaries this way.}

\classbox{Internally \src{CGrid} uses a \src{SplitDockGrid}. \src{SplitDockGrid} contains an algorithm that creates a \src{SplitDockTree}. This tree has dockables as leafs and relations between dockables are modeled as nodes. A \src{SplitDockTree} can be used by a \src{SplitDockStation} to build up its layout. }

\subsection{For all dockables: layout} \label{sec:layout}
The ``layout'' is the set of all locations, even including invisible dockables. \src{CControl} supports the storage and replacement of layouts automatically. \linebreak Clients only need to provide some factories for their custom dockables. A layout does not have direct references to any dockable, it is completely independent of gui-components.

There are four important methods in \src{CControl} used to interact with layouts:
\begin{itemize}
 \item \src{save} - stores the current layout. The method requires a \src{String} argument that is used as key for the layout. If a key is alread used then the old layout gets replaced with the new one.
 \item \src{load} - is the counterpart to \src{save}. It loads a layout that was stored earlier.
 \item \src{delete} - deletes a layout.
 \item \src{layouts} - returns all the keys that are in use for layouts.
\end{itemize}

\infobox{The class \src{CLayoutChoiceMenuPiece} can build some \src{JMenuItem}s that allow the user to save, load and delete layouts at any time. More about \src{MenuPiece}s can be found in chapter \ref{sec:menus}.}

\designbox{Layouts are divided into two subsets: ``entry'' and ``full'' layouts. An entry-layout does not store the location of any dockable that is associated with a working-area. A full-layout stores all locations. The method \src{save} always uses entry-layouts and a full-layout is only used when the applications properties are stored persistantly in a file.

Working-areas are intended to show some documents that are only temporarely available. Assuming that each dockable on a working-area represents one such document it makes perfectly sense not to replace them just because the user chooses another layout. Changing them would mean to close some documents and load other documents, and that is certainly not the behaviour the user would expect.}

\warningbox{The client is responsible to store the contents of any single-dockable. }

\subsubsection{Persistant Storage}
\src{Common} uses a class called \src{ApplicationResourceManager} to store its properties. Among other things all layout information is stored in this resource-manager. Normally any information in the resource-manager gots lost once the application shuts down. But clients can tell the resource-manager to write its contents into a file. Either they call \src{getResources} of \src{CControl} and then one of the many methods that start with ``write'' or they use directly \src{CControl}. An example:
\begin{lstlisting}
File file = new File( "layout.data" );

// write properties		
control.write( file );

// read properties
control.read( file );
\end{lstlisting}

\subsubsection{Dealing with lazy creation and missing dockables}
While \src{MultipleCDockable}s are created only when they are needed, \src{Common} assumes that \src{SingleCDockable}s are always present. However this assumption would require to create components that might never be shown. In order to solve the problem \src{SingleCDockableBackupFactory} was introduced. If a missing single-dockable is required the factories method \src{createBackup} is called. Assuming the factory returns not \src{null} then the new dockable is properly added to \src{CControl} and made visible.

\src{SingleCDockableBackupFactory}s need to be registered at the \src{CControl} using the method \src{addSingleBackupFactory}. They can also be removed using the method \src{removeSingleBackupFactory}. 

\infobox{If a dockable is removed from a \src{CControl} then normally all its associated location information is deleted. If however a backup-factory with the same id as the dockables id is registered, then the location information remains. If another dockable with the same id is later registered, then this new dockable inherits all settings from the old one.}

\classbox{\src{CControl}s behavior for missing dockables can be fine tuned with a \src{MissingCDockableStrategy}.} 

\section{Actions} \label{sec:action}
Actions are small graphical components associated with a dockable. They can show up a different locations, e.g. as buttons in the title.
\begin{figure}[ht]
\centering
\includegraphics[scale=1]{actions}
\caption{A set of actions on a dockable. The actions are the icons within the red oval.}
\label{fig:actions}
\end{figure}
An action is an instance of \src{CAction}. \src{Common} provides several subclasses of \src{CAction}. \src{CAction}s can be added to any \src{DefaultCDockable} through the method \src{addAction}. An example:
\begin{lstlisting}
DefaultCDockable dockable = ...
CAction action = new ...

dockable.addAction( action )
\end{lstlisting}

To separate a group actions from another group a separator is needed. The method \src{addSeparator} of \src{DefaultCDockable} adds such a separator. The separator will behave like a \src{CAction}.

An action is not a \src{Component}, it can appear at the same time at different locations with different views. For example an action can be seen as button in a title and at the same time as menu-item in a popup-menu.

\subsection{CButton}
\src{CButton}s are actions that can be triggered many times by the user and will always behave the same way. \src{CButton}s need to be subclassed, its abstract method \src{action} will be called whenever the button is triggered. An example:
\begin{lstlisting}
public class SomeAction extends CButton{
	public SomeAction(){
		setText( "Something" );
	}
	
	protected void action(){
		...
	}
}
\end{lstlisting}

\subsection{CCheckBox}
This action has a state, it is either selected or not selected (\src{true} or \src{false}). Whenever the user triggers the action the state changes. Like \src{CButton} is must be subclassed. The method \src{changed} will be called when the state changes. An example:
\begin{lstlisting}
public class SomeAction extends CCheckBox{
	public SomeAction(){
		setText( "Something" );
	}
	
	protected void action(){
		boolean selected = isSelected();
		...
	}
}
\end{lstlisting}

\subsection{CRadioButton}
In most aspects the \src{CRadioButton} behaves like a \src{CCheckBox}. \src{CRadioButton}s are grouped together, the user can always select on of the buttons. A group of is realized with the help of the class \src{CRadioGroup}:
\begin{lstlisting}
CRadioButton buttonA = ...
CRadioButton buttonB = ...

CRadioGroup group = new CRadioGroup();

group.add( buttonA );
group.add( buttonB );
\end{lstlisting}

\subsection{CMenu}
A \src{CMenu} is a list of \src{CAction}s. The user can open the \src{CMenu} and it will show a popup-menu with its actions. Clients can add and remove actions from a \src{CMenu} through methods like \src{add}, \src{insert}, or \src{remove}.

\begin{figure}[ht]
\centering
\includegraphics[scale=1]{cmenu}
\caption{An open \src{CMenu}. The action itself is at the top within the red circle. Its menu consists of \src{CButton}s and a separator, the menu is within the blue oval.}
\label{fig:cmenu}
\end{figure}

\subsection{CDropDownButton}
A \src{CDropDownButton} consists of two buttons. One of them opens a menu, the other one triggers the last selected item of that menu again. 

\begin{figure}[ht]
\centering
\includegraphics[scale=1]{cdropdown}
\caption{A \src{CDropDownButton} within a red circle.}
\label{fig:cdropdown}
\end{figure}

The behavior of \src{CDropDownButton} can be influenced through its items. This requires that the items are subclasses of \src{CDropDownItem}. \src{CButton}, \src{CCheckBox} and \src{CRadioButton} fulfill this requirement. There are three properties to set:
\begin{itemize}
 \item \src{dropDownSelectable} - whether the action can be selected at all. If not, then clicking onto the item might trigger it, but the drop-down-buttons icon and text will remain unchanged.
 \item \src{dropDownTriggerableNotSelected} - if not set, then this item cannot be triggered if not selected. As a consequence the item must be clicked twice until it reacts.
 \item \src{dropDownTriggerableSelected} - if not set, then this item cannot be triggered if selected. It still can be triggered by opening the menu and then clicking onto the item.
\end{itemize}
If a \src{CDropDownButton} cannot trigger its selected item, then it just opens its menu.

\subsection{CBlank}
This action is not visible and does nothing. It can be used as placeholder where a \src{null} reference would cause problems, e.g. because \src{null} is sometimes replaced by some default value.

\subsection{System Actions}
\src{Common} adds a number of actions to any \src{CDockable}, e.g.: the close-button. These actions are deeply hidden within the system and cannot be accessed. There is however a mechanism to replace them with custom actions. Each \src{CDockable} has a method \src{getAction} which is called before a system action is put in place. If this method does return anything else than \src{null} then the system action gets replaced. \src{AbstractCDockable} offers the method \src{putAction} to set these replacements. An example:
\begin{lstlisting}
SingleCDockable dockable = ...
CAction replacement = ...

dockable.putAction( CDockable.ACTION_KEY_MAXIMIZE, replacement );
\end{lstlisting}
In this example whenever the maximize-action of \src{dockable} should be visible, \src{replacement} is shown. This feature should of course be treated with respect, changing the behavior of an action can confuse the user a lot.

\classbox{The class \src{CCloseAction} is an action that closes any dockable on which it is shown. The subclasses of \src{CExtendedModeAction} change the extended-mode of their dockables.}

\subsection{Custom Actions}
Clients are free to write their custom actions. They need to implement a new \src{DockAction} and a subclass of \src{CAction}. The subclass can give its super-class an instance of the custom \src{DockAction} or call \src{init} to set the action. Please refere to the guide for \src{Core} to find out how to implement a \src{DockAction}.

\section{Customizing: small but impressive}
\src{Common} allows to customize some behavior and components. Understanding these features is not necessary to work with \src{Common}, but impressive effects can be built with them. This chapter will, without any specific order, introduce some of these features.

\subsection{Color}
Every dockable has a \src{ColorMap}. This map contains colors that are used in the graphical user interface. Normally the map is empty and some default colors are used. If a client puts some colors into the \src{ColorMap}, then the user interface is immediatelly updated using the new colors. \src{ColorMap} itself contains a set of keys that can be used, as an example:
\begin{lstlisting}
CDockable dockable = ...
ColorMap map = dockable.getColors();
map.setColor( ColorMap.COLOR_KEY_TAB_BACKGROUND, Color.RED );
\end{lstlisting}

\infobox{Some keys are specialications of other keys. For example \src{COLOR\_KEY\_TAB\_BACKGROUND} changes the background of tabs, while \src{COLOR\_KEY\_TAB\_BACKGROUND\_FOCUSED} changes the background of focused tabs only. A specialized key overrides the value provided by a general key.}

\warningbox{Colors require the support of a \src{DockTheme} that applies them. Only themes of \src{Common} do that, the original themes of \src{Core} will render the \src{ColorMap} useless. In \src{Common} clients should interact with themes only through the \src{ThemeMap}, this map will make sure that only themes are used that support colors.

Also note that some \src{Components}, like the \src{JTabbedPane}, and some \src{LookAndFeel}s do not support custom colors. }

\subsection{Font}
Exactly like the color, fonts of dockables can be exchanged. Each dockable has a \src{FontMap} which contains \src{FontModifiers}. \src{FontModifiers} can change some property of a font, an example:
\begin{lstlisting}
CDockable dockable;
FontMap fonts = dockable.getFonts();

GenericFontModifier italic = new GenericFontModifier();
italic.setItalic( GenericFontModifier.Modify.ON );
fonts.setFont( FontMap.FONT_KEY_TAB, italic );
\end{lstlisting}
The \src{FontModifier} \src{italic} will change the italic flag of the original font to \src{true} (line \src{5}).

\warningbox{Some \src{Components}, like the \src{JTabbedPane}, and some \src{LookAndFeel}s do not support custom fonts. In this case the settings are just ignored. }

\subsection{Size} \label{sec:size}
Every dockable has a width and a height. Some dockables are flexibel in their size, others would be better of with a constant size. There is a feature to lock the size and a feature to set a specific size.

\subsubsection{Lock the size}
Every \src{AbstractCDockable} has the method \src{setResizeLocked}. If the size is locked through this method than any station will try not to change the size of the dockable. There are also methods to lock only width or height (\src{setResizeLockedHorizontally} and \src{setResizeLockedVertically}).

\warningbox{Locking the size does not prevent the user from manually resizing the dockable. And sometimes a station needs to violate the locking as well, e.g.: when a grid-area has only one child the size cannot be choosen freely. }

\subsubsection{Request a size}
It is also possible for client code to request a specific size for one or many \src{CDockable}s. Clients need to call \src{setResizeRequest} and \src{handleResizeRequest} like in the example below:

\begin{lstlisting}
CControl control = ...

DefaultCDockable a = ...
DefaultCDockable b = ...

a.setResizeRequest( new Dimension( 200, 300 ), false );
b.setResizeRequest( new RequestDimension( 500, true ), false );

control.handleResizeRequests();
\end{lstlisting}
In this example to resize requests are handled at the same time. In line \src{6} the resize request of \src{a} is set to $200, 300$, the argument \src{false} tells \src{a} not yet to process the request. In line \src{7} the resize request of \src{b} is set, \src{b} should have the width $500$ but should not care about its height. Finally in line \src{9} all the requests are processed together. If the second parameter in line \src{7} would be \src{true} instead of \src{false}, then line \src{9} would not be necessary.

\designbox{Not processing a request directly, but collect them, allows requests to interact with each other. Assume three dockables in a line and the task to resize the two elements at the begin and end of the line. If one resize request is handled before the other, than the second request might destroy the work of the first one.}

\classbox{Every object can add a \src{ResizeRequestListener} to \src{CControl}, this listener will be called when resize requests need to be processed. Most of the \src{CStation}s add such a listener. The only station on which requests can have complex interactions is the \src{CGridArea} (and the \src{CContentArea}). With the \src{PropertyKey} \src{RESIZE\_LOCK\_CONFLICT\_RESOLVER}, defined in \src{CControl}, clients can set the algorithm that is used to solve contradictions in a \src{CGridArea}.}

\subsection{Maximizing}
When maximizing a \src{CDockable} first the global \src{CMaximizeBehavior} is asked for the real element to maximize. If for example a dockable is part of a whole stack of dockables, then the maximize-behavior might decide to maximize the whole stack instead of the single dockable. In a second step the tree of stations and dockables is traversed upwards until a \src{MaximizeArea} is found, the element is then shown on this area. If no \src{MaximizeArea} can be found in the ancestors, then a default area is taken.

Clients are not (yet) able to influence the second step, but they can change the \src{CMaximizeBehavior}:
\begin{lstlisting}
CControl control = ...
CMaximizeBehaviour behaviour = ...

control.getStateManager().setMaximizeBehavior( behavior );
\end{lstlisting}
In line \src{2} a custom behavior is declared, in line \src{4} the behavior is set.

\classbox{Most the things that need to be done for changing the extended mode (like the ``maximized mode'') are handled by the \src{CStateManager}.}

\subsection{Preferences} \label{sec:preferences}
Common allows users to set some properties like the keys that need to be pressed in order to maximize a dockable (\src{ctrl+m}). Normally this mechanism is deactivated and clients first need to activate it:
\begin{lstlisting}
CControl control = ...
PreferenceModel preferences = new CPreferenceModel( control );

control.setPreferenceModel( preferences );
\end{lstlisting}
This piece of code activates the preference mechanism. In line \src{2} the set of preferences that can be changed by the user is setup, a \src{CPreferenceModel} is often the best choice. Then in line \src{4} the model is connected to \src{control}. Calling \src{setPreferenceModel} will activate persistant storage for \src{model} and also immediatelly load values into the model.

The model can later be presented to the user:
\begin{lstlisting}
CControl control = ...
PreferenceModel model = control.getPreferenceModel();
Component owner = control.intern().getController().findRootWindow();

if( model instanceof PreferenceTreeModel ){
	PreferenceTreeModel tree = (PreferenceTreeModel)model;
	PreferenceTreeDialog.openDialog( tree, owner );
}
else{
	PreferenceDialog.openDialog( model, owner );
}
\end{lstlisting}
In line \src{3} the root window of the application is searched, it is used as parent window for any dialog that needs to be opened. In line \src{7} or line \src{10} a dialog is opened that shows the preferences. There are two different dialogs, one with a tree at the left side to make select a subset of preferences, one without tree.

\classbox{There are different preference models. \src{CPreferenceModel} contains all possible preferences for Common, it consists of four other models:
\begin{itemize}
 \item \src{CKeyStrokePreferenceModel}: The different key combinations that, when pressed, initiate some action.
 \item \src{CLayoutPreferenceModel}: General settings for the themes.
 \item \src{BubbleThemePreferenceModel}: Settings affecting the eclipse-theme.
 \item \src{EclipseThemePreferenceModel}: Settigns affecting the bubble-theme.
\end{itemize}

Internally each item of the model is a \src{Preference}, clients can put together their own model. }

\infobox{The class \src{CPreferenceMenuPiece} can act as a menu-item for opening the preference-dialog, read more about menus in chapter \ref{sec:menus}. }

\subsection{Themes} \label{sec:theme}
A theme sets look and behavior of \src{DockingFrames}. Themes are managed by the \src{ThemeMap}, this map contains \src{String}s as keys and \src{ThemeFactory}s as values. \src{ThemeMap} is however more than just a map, it also tells which theme is currently selected. Clients can call \src{select} to change the selection.

In the current version 5 themes are always installed per default, the keys of these 5 themes are stored as constants directly in \src{ThemeMap}.

Working with the \src{ThemeMap} could look like this:
\begin{lstlisting}
CControl control = ...
ThemeMap themes = control.getThemes();

themes.select( ThemeMap.KEY_FLAT_THEME );

themes.add( "custom", new CustomFactory() );
\end{lstlisting}
In line \src{2} the map is accessed. In line \src{4} one of the preinstalled themes is selected, this theme is applied to \src{control}. In line \src{6} a factory for a custom theme is installed.

\designbox{A theme has much freedom in how to present the dockables. But \src{Common} allows clients to set color and font of various elements associated with a \src{CDockable}. The standard themes of \src{Core} would not respect these settings, hence \src{Common} needs some modified themes.

The \src{ThemeMap} is an attempt to hide this ugly fact from developers and to make sure they don't use the wrong theme.}

\subsection{LookAndFeel} \label{sec:lookandfeel}
\src{LookAndFeel} tells a \src{Swing} application how to paint things and how to behave. The relation between \src{LookAndFeel} and \src{Swing} is like the relation between theme and \src{DockingFrames}. The \src{LookAndFeel} can be changed while the application runs, but the method \src{updateUI} must be called for each and every existing \src{JComponent} by the client itself.

Of course, clients are free to implement such a function. \src{DockingFrames} will detect a change of the \src{LookAndFeel} and update itself where necessary, but it will not update the \src{JComponent}s.

But \src{Common} includes better support for \src{LookAndFeel} changes. The class \src{LookAndFeelList} provides a list of all available \src{LookAndFeel}s and allows to change the current selection. Per default the list does not exist but clients can easily create one:

\begin{lstlisting}
LookAndFeelList list = LookAndFeelList.getDefaultList();

CControl control = ...

ComponentCollector collector = 
	new DockableCollector( control.intern() );
list.addComponentCollector( collector );

XElement xsettings = ...
list.readXML( xsettings );
\end{lstlisting}


\subsection{Menus} \label{sec:menus}
Most \src{Swing} applications use menus (like in figure \ref{fig:menus}). \src{DockingFrames} contains a few actions that fit nicely into a menu, for example store and load a layout.

For a given option the number of required menu-items may change during runtime, e.g. every stored layout requires one item. But developers may not want to add one \src{JMenu} for each option of \src{DF}. To resolve this problem \src{Common} introduces a very small framework that allows the management of dynamically growing or shrinking menus.

\begin{figure}[ht]
\centering
\includegraphics[scale=1]{menus}
\caption{Some menus.}
\label{fig:menus}
\end{figure}

The most important class of the menu-framework is the \src{MenuPiece}. Basically a \src{MenuPiece} is a list of \src{Components} which informs observers if it changes its size. There are around 15 subclasses of \src{MenuPiece}, they allow to compose many pieces to one big piece or have more specific duties like providing the stored layouts.

An incomplete list of composing \src{MenuPiece}s contains:
\begin{description}
 \item [\src{RootMenuPiece}]: Represents a whole \src{JMenu}.
 \item [\src{SubMenuPiece}]: A wrapper around a \src{RootMenuPiece} allowing it to act like a submenu.
 \item [\src{NodeMenuPiece}]: Just a list of \src{MenuPiece}s that act like one big piece.
 \item [\src{SeparatingMenuPiece}]: A wrapper around another \src{MenuPiece} introducing separators at the top and/or bottom.
\end{description}

\classbox{Other \src{MenuPiece}s that might be interesting are:
\begin{description}
 \item [\src{BaseMenuPiece}]: A good base class for custom \src{MenuPiece}s, allows to add or remove \src{Component}s directly.
 \item [\src{FreeMenuPiece}]: A piece that does not add children by itself but has public methods which can be invoked by clients to modify the piece directly.
\end{description}
}

In the remainder of this section the more complex \src{MenuPiece}s are introduced.

\subsubsection{Themes}
\src{Common} has several themes built in, a theme tells how to paint certain components or how to react on certain events. The theme mechanism is described in more detail in chapter \ref{sec:theme}.

Clients can use a \src{CThemeMenuPiece} to quickly create a menu that changes the theme. The menu tracks changes in the \src{ThemeMap} of the associated \src{CControl}.

\warningbox{If a \src{CThemeMenuPiece} is no longer required, then clients should call its method \src{destroy}. }

\subsubsection{LookAndFeel}
\src{Common} already supports \src{LookAndFeel}s, more about this feature can be read in chapter \ref{sec:lookandfeel}. The \src{CLookAndFeelMenuPiece} adds a menu that lists all the available \src{LookAndFeel}s and allows to exchange them.

\warningbox{If a \src{CLookAndFeelMenuPiece} is no longer required, then clients should call its method \src{destroy}. }

\infobox{Each \src{CLookAndFeelMenuPiece} will store the selection persistant, assuming that clients call \src{write} of \src{CControl} or of \src{ApplicationResourceManager}. If this behavior is not whished, then the \src{LookAndFeelMenuPiece} provides similar behavior but without the persistant storage.}

\subsubsection{Layout}
The layout is the location of all dockables as described in chapter \ref{sec:layout}. The \src{CLayoutChoiceMenuPiece} offers users several actions to work with layouts:
\begin{description}
 \item [Save]: Saves the current layout. If the current layout has not yet a name then a dialog pops up so the user can enter a name.
 \item [Save As]: Saves the current layout but always asks the user to enter a new name for the layout.
 \item [Load]: Loads a previously saved layout, the current layout gets not stored.
 \item [Delete]: Deletes a previously saved layout.
\end{description}

\subsubsection{List of Dockables}
All closeable \src{SincleCDockable}s known to a \src{CControl} can be listed in a \src{SingleCDockableListMenuPiece}. The user can make the dockables visible or invisible from the menu. The menu will update its content automatically as dockables are added or removed from the \src{CControl}.

\subsubsection{Preferences}
\src{Common} supports preferences as described in chapter \ref{sec:preferences}. \src{CPreferenceMenuPiece} adds a single item that opens a dialog with the preferences of a \src{CControl}.

\warningbox{Per default the preference system is disabled. Clients can acivate the preference system in two ways:
\begin{itemize}
 \item Call \src{setPreferenceModel} of \src{CControl} with the preferences that should be editable.
 \item Call \src{setup} of \src{CPreferenceMenuPiece} to optain a new menu and set the default model (\src{CPreferenceModel}) in the same step.
\end{itemize}
}

\section{Suggestions}
Users and developers made a lot of good suggestions, this chapter is an incomplete list of them.

Some word of warning: this is an open source project, as such its developer(s) are not so much interested in selling the framework to as many people as possible, but on having fun writing something cool. Hence some things that people would like to have will never be implemented because the developers don't have fun doing this stuff. 

\subsection{Of people using the library}

\begin{itemize}
 \qa{When showing tabs, would it be possible to show a drop-down menu when there is not enough space for all the tabs?}{This will be implemented and has high priority.}
 
 \qa{Tabs: would it be possible to show them on the left, right, bottom, top rotate etc...?}{Whilst it would be easy to just put them at another place, there needs more to be done. This feature requires to upgrade most of the painting code. In theory the \src{StackDockComponent} would already provide developers with the ability to use their very own tabs (at their own place), but not to reuse the existing tabs. More settings would be a nice improvement of the framework and will most certainly be implemented.}
 
 \qa{AWT, it needs better support (e.g. things should be painted over AWT panels as well).}{AWT and Swing don't work together. This framework is based on Swing, any attempt to support AWT will result in a lot of ugly hacks. Also given the fact that AWT isn't hardly used anymore (except for applications playing video or rendering 3D scenes) this feature has little to none chances of getting implemented.}
 
  \qa{Could the framework be made available for [insert your favorite tool here]? E.g. in a Maven repository or for the Netbeans GUI Builder.}{Making the framework available in/for any special tool immediately results in two important problems. First, as soon as one tool is supported people will ask for another tool, this will never end... Second, a library does no get better because it does support many other tools, it does get better because it has lesser bugs, more settings or features.}
 
 \qa{Assume an externalized \src{CDockable}, if it gets maximized, could it be maximized like a \src{JFrame}? It would will the entire screen instead of falling back to the nearest \src{CContentArea}.}{This is a good idea. It is not yet clear how to implement this, but it is among those things that will be done.}
 
\end{itemize}

\subsection{Of the developers}
Since the framework has its own forum many questions have been asked, and most of them were answered as well. From these questions some observations can be made:

\begin{itemize}
 \item Problems arise both in Core and in Common. The problems are however of different nature. In Core most problems concern small things, e.g. how to place the tabs. Most of these problems can be solved with small patches. 
 
 The problems related to Common are a lot more serious. Often the answer is ``Common is not able to do that''. And even worse, there is often no small patch. In short: \textit{Common has serious design flaws}. Especially Common lacks the ability to customize components.
 
 Hence most future work must be spent on Common.
 
 \item The features now available seem to be sufficient for most applications. The requests for things that are entirely missing has dropped to almost zero. There is no need for new features, there is need to improve existing features.
\end{itemize}

Putting the pieces together the areas that will make the framework better are most likely:
\begin{itemize}
 \item The \src{StateManager}, this class is responsible for managing the ``extended mode''. The class has continually grown and has become a major hindrance for customization. Currently there is absolutely no abstraction in this class, it needs to redesigned from scratch. This class is almost as important as \src{DockController} or \src{CControl}, its redesign will affect a lot of other classes. The effect will be, that a) any station can have any function, or many functions at the same time (e.g. minimizing could be mapped to a custom component). And b) clients would be able to introduce their very own extended modes.
 \item \src{CControl} and other classes use a lot of anonymous classes. They need to be named and made public, and clients need to be able to exchange them by their own implementations. New factories, also factories with customizable properties, could help.
 \item Clients need more control over \src{CDockable}s, or better their representation as \src{Dockable}. One possibility would be a second series of \src{CDockable}s that extend directly \src{DefaultDockable}.
 \item There should also be more observers, clients should be able to register and react (or cancel) to almost all actions of the framework.
\end{itemize}

\section{Properties}
\src{Core} allows clients to set a number of properties, \src{Common} adds a few more. All properties can be set or read by \src{putProperty} and \src{getProperty} of \src{CControl}. An example:
\begin{lstlisting}
CControl control = ...

PropertyKey<KeyStroke> key = control.KEY_CLOSE;
KeyStroke value = KeyStroke.getKeyStroke( "shift X" );

control.putProperty( key, value );
\end{lstlisting}

All properties of \src{Common} are stored as constants in \src{CControl}. The complete list:
\begin{description}
\property{CControl.KEY\_MAXIMIZE\_CHANGE}{KeyStroke}{\src{ctrl + m}}{If pressed then the focused dockables changes between maximized and normal state.}
\property{KEY\_GOTO\_MAXIMIZED}{KeyStroke}{\src{null}}{If pressed then the focused dockable becomes maximized.}
\property{KEY\_GOTO\_NORMALIZED}{KeyStroke}{ctrl + n}{If pressed then the focused dockable becomes normalized.}
\property{KEY\_GOTO\_MINIMIZED}{KeyStroke}{\src{null}}{If pressed then the focused dockable becomes minimized.}
\property{KEY\_GOTO\_EXTERNALIZED}{KeyStroke}{\src{ctrl + e}}{If pressed then the focused dockable becomes externalized.}
\property{KEY\_CLOSE}{KeyStroke}{\src{ctrl + F4}}{If pressed then the focused dockable is made invisible.}
\property{RESIZE\_LOCK\_CONFLICT\_RESOLVER}{ConflictResolver<RequestDimension>}{an instance of \src{DefaultConflictResolver}}{Tells how to distribute space when two or more dockables have conflicting size requests. See also chapter \ref{sec:size}.}
\end{description}


\end{document}